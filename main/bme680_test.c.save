#include <stdio.h>
#include <string.h>
#include <math.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "esp_log.h"
#include "driver/i2c.h"
#include "esp_timer.h"

#include "bme68x.h"
#include "bme68x_defs.h"

#include "bsec_interface.h"
#include "bsec_datatypes.h"
#include "bsec_iaq.h"

/* ================= I2C CONFIG ================= */
#define I2C_MASTER_NUM       I2C_NUM_0
#define I2C_MASTER_SDA_IO    21
#define I2C_MASTER_SCL_IO    22
#define I2C_MASTER_FREQ_HZ   100000

#define BME68X_I2C_ADDR      BME68X_I2C_ADDR_LOW  // 0x76
/* =============================================== */

static const char *TAG = "BME680";

/* ================= I2C FUNCTIONS ================= */
static int8_t i2c_read(uint8_t reg, uint8_t *data, uint32_t len, void *intf_ptr)
{
    uint8_t dev_addr = *(uint8_t *)intf_ptr;
    
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (dev_addr << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, reg, true);
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (dev_addr << 1) | I2C_MASTER_READ, true);
    
    if (len > 1)
        i2c_master_read(cmd, data, len - 1, I2C_MASTER_ACK);
    
    i2c_master_read_byte(cmd, data + len - 1, I2C_MASTER_NACK);
    i2c_master_stop(cmd);
    
    esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd);
    
    return (ret == ESP_OK) ? BME68X_OK : BME68X_E_COM_FAIL;
}

static int8_t i2c_write(uint8_t reg, const uint8_t *data, uint32_t len, void *intf_ptr)
{
    uint8_t dev_addr = *(uint8_t *)intf_ptr;
    
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, (dev_addr << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(cmd, reg, true);
    i2c_master_write(cmd, (uint8_t *)data, len, true);
    i2c_master_stop(cmd);
    
    esp_err_t ret = i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, pdMS_TO_TICKS(1000));
    i2c_cmd_link_delete(cmd);
    
    return (ret == ESP_OK) ? BME68X_OK : BME68X_E_COM_FAIL;
}

static void delay_us(uint32_t period, void *intf_ptr)
{
    vTaskDelay(pdMS_TO_TICKS(period / 1000));
}

/* ================= BSEC HELPER ================= */
static void check_bsec_status(bsec_library_return_t bsec_status)
{
    if (bsec_status != BSEC_OK) {
        ESP_LOGE(TAG, "BSEC error: %d", bsec_status);
    }
}

/* ================= MAIN APP ================= */
void app_main(void)
{
    /* -------- I2C INIT -------- */
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = I2C_MASTER_SDA_IO,
        .scl_io_num = I2C_MASTER_SCL_IO,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_MASTER_FREQ_HZ
    };
    
    ESP_ERROR_CHECK(i2c_param_config(I2C_MASTER_NUM, &conf));
    ESP_ERROR_CHECK(i2c_driver_install(I2C_MASTER_NUM, conf.mode, 0, 0, 0));
    
    ESP_LOGI(TAG, "I2C initialized");
    
    /* -------- BME680 INIT -------- */
    struct bme68x_dev dev;
    struct bme68x_conf conf_sensor;
    struct bme68x_heatr_conf heatr_conf;
    struct bme68x_data data;
    uint8_t n_fields;
    
    uint8_t dev_addr = BME68X_I2C_ADDR;
    
    dev.intf = BME68X_I2C_INTF;
    dev.intf_ptr = &dev_addr;
    dev.read = i2c_read;
    dev.write = i2c_write;
    dev.delay_us = delay_us;
    dev.amb_temp = 25;
    
    if (bme68x_init(&dev) != BME68X_OK) {
        ESP_LOGE(TAG, "BME680 init failed");
        return;
    }
    
    ESP_LOGI(TAG, "BME680 initialized");
    
    /* -------- SENSOR CONFIG -------- */
    conf_sensor.os_hum  = BME68X_OS_2X;
    conf_sensor.os_pres = BME68X_OS_4X;
    conf_sensor.os_temp = BME68X_OS_8X;
    conf_sensor.filter  = BME68X_FILTER_SIZE_3;
    
    bme68x_set_conf(&conf_sensor, &dev);
    
    heatr_conf.enable = BME68X_ENABLE;
    heatr_conf.heatr_temp = 300;
    heatr_conf.heatr_dur = 100;
    
    bme68x_set_heatr_conf(BME68X_FORCED_MODE, &heatr_conf, &dev);
    
    /* -------- BSEC INIT -------- */
    bsec_library_return_t bsec_status;
    
    bsec_status = bsec_init();
    check_bsec_status(bsec_status);
    
    ESP_LOGI(TAG, "BSEC initialized");
    
    /* -------- BSEC CONFIG -------- */
    bsec_status = bsec_set_configuration(
        bsec_config_iaq,
        sizeof(bsec_config_iaq),
        NULL,
        0
    );
    check_bsec_status(bsec_status);
    
    ESP_LOGI(TAG, "BSEC config loaded");
    
    /* -------- MAIN LOOP -------- */
    while (1) {
        /* Read BME680 */
        bme68x_set_op_mode(BME68X_FORCED_MODE, &dev);
        vTaskDelay(pdMS_TO_TICKS(250));
        
        if (bme68x_get_data(BME68X_FORCED_MODE, &data, &n_fields, &dev) != BME68X_OK || n_fields == 0) {
            vTaskDelay(pdMS_TO_TICKS(3000));
            continue;
        }
        
        bool gas_valid = (data.status & BME68X_GASM_VALID_MSK) && 
                         (data.status & BME68X_HEAT_STAB_MSK);
        
        /* Prepare inputs for BSEC */
        bsec_input_t inputs[BSEC_MAX_PHYSICAL_SENSOR];
        uint8_t n_inputs = 0;
        
        int64_t timestamp_ns = esp_timer_get_time() * 1000; // µs → ns
        
        /* Temperature */
        inputs[n_inputs].sensor_id = BSEC_INPUT_TEMPERATURE;
        inputs[n_inputs].signal = data.temperature;
        inputs[n_inputs].time_stamp = timestamp_ns;
        n_inputs++;
        
        /* Humidity */
        inputs[n_inputs].sensor_id = BSEC_INPUT_HUMIDITY;
        inputs[n_inputs].signal = data.humidity;
        inputs[n_inputs].time_stamp = timestamp_ns;
        n_inputs++;
        
        /* Pressure (convert hPa → Pa) */
        inputs[n_inputs].sensor_id = BSEC_INPUT_PRESSURE;
        inputs[n_inputs].signal = data.pressure * 100.0f;
        inputs[n_inputs].time_stamp = timestamp_ns;
        n_inputs++;
        
        /* Gas (if valid) */
        if (gas_valid) {
            inputs[n_inputs].sensor_id = BSEC_INPUT_GASRESISTOR;
            inputs[n_inputs].signal = data.gas_resistance;
            inputs[n_inputs].time_stamp = timestamp_ns;
            n_inputs++;
        }
        
        /* Run BSEC algorithm */
        bsec_output_t outputs[BSEC_NUMBER_OUTPUTS];
        uint8_t n_outputs = 0;
        
        bsec_status = bsec_do_steps(inputs, n_inputs, outputs, &n_outputs);
        
        if (bsec_status == BSEC_OK) {
            /* Print raw sensor data */
            ESP_LOGI(TAG, "RAW: T=%.2f°C H=%.2f%% P=%.2fhPa G=%luΩ %s",
                     data.temperature,
                     data.humidity,
                     data.pressure / 100.0f,
                     data.gas_resistance,
                     gas_valid ? "(valid)" : "(invalid)");
            
            /* Process BSEC outputs */
            for (int i = 0; i < n_outputs; i++) {
                switch (outputs[i].sensor_id) {
                    case BSEC_OUTPUT_IAQ:
                        ESP_LOGI(TAG, "IAQ: %.0f (Accuracy: %d)",
                                 outputs[i].signal,
                                 outputs[i].accuracy);
                        break;
                        
                    case BSEC_OUTPUT_CO2_EQUIVALENT:
                        ESP_LOGI(TAG, "eCO₂: %.0f ppm",
                                 outputs[i].signal);
                        break;
                        
                    case BSEC_OUTPUT_BREATH_VOC_EQUIVALENT:
                        ESP_LOGI(TAG, "bVOC: %.3f ppm",
                                 outputs[i].signal);
                        break;
                        
                    case BSEC_OUTPUT_SENSOR_HEAT_COMPENSATED_TEMPERATURE:
                        ESP_LOGI(TAG, "Comp Temp: %.2f°C",
                                 outputs[i].signal);
                        break;
                        
                    case BSEC_OUTPUT_SENSOR_HEAT_COMPENSATED_HUMIDITY:
                        ESP_LOGI(TAG, "Comp Hum: %.2f%%",
                                 outputs[i].signal);
                        break;
                        
                    case BSEC_OUTPUT_RAW_GAS:
                        ESP_LOGI(TAG, "Comp Gas: %.0fΩ",
                                 outputs[i].signal);
                        break;
                }
            }
            
            if (n_outputs > 0) {
                ESP_LOGI(TAG, "---");
            }
        }
        
        /* Wait 3 seconds (BSEC requirement) */
        vTaskDelay(pdMS_TO_TICKS(3000));
    }
}
